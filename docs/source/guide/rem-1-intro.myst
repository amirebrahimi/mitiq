---
jupytext:
  text_representation:
    extension: .myst
    format_name: myst
    format_version: 0.13
    jupytext_version: 1.11.1
kernelspec:
  display_name: Python 3 (ipykernel)
  language: python
  name: python3
---

# How do I use REM?

As with all techniques, REM is compatible with any frontend supported by Mitiq:

```{code-cell} ipython3
import mitiq

mitiq.SUPPORTED_PROGRAM_TYPES.keys()
```


## Problem setup
This example uses a Z0 + Z1 observable with a circuit that flips each qubit to 
the |1> state. However, this is an incredibly noisy device where each qubit's
readout is flipped. So, we mitigate these error results with REM.

```{code-cell} ipython3
from cirq import LineQubit, Circuit, X, measure_each

from mitiq.observable.observable import Observable
from mitiq.observable.pauli import PauliString

qreg = [LineQubit(i) for i in range(2)]
circuit = Circuit(X.on_each(*qreg), measure_each(*qreg))
observable = Observable(PauliString("ZI"), PauliString("IZ"))

print(circuit)
```

Next we define a simple noisy readout executor function which takes a 
circuit as input, executes the circuit on a noisy simulator, and 
returns the raw measurement results. See the [Executors](executors.myst) 
section for more information on how to define more advanced executors.

```{code-cell} ipython3
from functools import partial

import numpy as np
from cirq.experiments.single_qubit_readout_calibration_test import (
    NoisySingleQubitReadoutSampler,
)

from mitiq._typing import MeasurementResult

def noisy_readout_executor(
    circuit, p0: float = 0.01, p1: float = 0.01, shots: int = 8192
) -> MeasurementResult:
    # Replace with code based on your frontend and backend.
    simulator = NoisySingleQubitReadoutSampler(p0, p1)
    result = simulator.run(circuit, repetitions=shots)

    return MeasurementResult(
        result=np.column_stack(list(result.measurements.values())),
        qubit_indices=tuple(
            # q[2:-1] is necessary to convert "q(number)" into "number"
            int(q[2:-1])
            for k in result.measurements.keys()
            for q in k.split(",")
        ),
    )
```

The [executor](executors.myst) can be used to evaluate noisy (unmitigated)
expectation values.

```{code-cell} ipython3
from mitiq.raw import execute as raw_execute

# Compute the expectation value of the observable.
# Use a noisy executor that completely flips results
noisy_executor = partial(noisy_readout_executor, p0=1, p1=1)
noisy_value = raw_execute(circuit, noisy_executor, observable)

ideal_executor = partial(noisy_readout_executor, p0=0, p1=0)
ideal_value = raw_execute(circuit, ideal_executor, observable)
print(f"Error without mitigation: {abs((ideal_value - noisy_value)/ideal_value) :.3}")
```

## Apply REM to raw readout results
Readout-error mitigation can be easily applied with the function
{func}`.execute_with_rem()`.

```{code-cell} ipython3
from mitiq import rem

inverse_confusion_matrix = np.array(
    [
        [0, 0, 0, 1],
        [0, 0, 1, 0],
        [0, 1, 0, 0],
        [1, 0, 0, 0],
    ]
)

mitigated_result = rem.execute_with_rem(
    circuit,
    noisy_executor,
    observable,
    inverse_confusion_matrix=inverse_confusion_matrix,
)
```

```{code-cell} ipython3
print(f"Error with mitigation (REM): {abs((ideal_value - mitigated_result)/ideal_value) :.3}")
```

Here we observe that the application of REM eliminates the readout error when compared
to the unmitigated result.

```{note} 
It is necessary to supply the inverse confusion matrix to the REM technique.
There are various approaches that can be used to generate the inverse 
confusion matrix with some being more costly than others.
```

+++

The section
[What additional options are available when using REM?](rem-3-options.myst)
contains more information on generating inverse confusion matrices in order to 
apply REM with Mitiq.
